# CollabCanvas Code Quality Rules

## DRY Principle (Don't Repeat Yourself)
- NEVER duplicate code. If you see similar logic in 2+ places, immediately refactor into a shared function.
- Before writing new code, search the codebase for similar patterns that can be reused.
- If you're copy-pasting code, STOP and create a reusable function instead.
- Common duplication to watch for:
  - Shape creation logic → utils/shapeFactory.ts
  - WebSocket message handling → utils/websocket.ts
  - Canvas coordinate calculations → utils/geometry.ts
  - State updates → store/actions.ts
  - Validation logic → utils/validation.ts

## Code Organization & Modularity

### File Structure Standards
```
src/
├── components/        # React components (UI only)
├── hooks/            # Reusable React hooks
├── utils/            # Pure utility functions
├── store/            # State management
├── services/         # API calls, external services
├── tools/            # LangChain tools
├── types/            # TypeScript types/interfaces
└── constants/        # Shared constants
```

### Function Modularity Rules
1. **Single Responsibility**: Each function should do ONE thing well
2. **Max 50 lines**: If a function exceeds 50 lines, break it into smaller functions
3. **Pure functions preferred**: Avoid side effects when possible
4. **Extract common patterns**: If logic appears 2+ times, extract to utils/

### Where to Put Functions

#### Canvas/Shape Operations → `utils/canvas.ts`
```typescript
// ✅ Good - centralized canvas utilities
export function createShape(type, props) { ... }
export function updateShapePosition(shape, x, y) { ... }
export function getShapeBounds(shape) { ... }
export function isPointInShape(point, shape) { ... }
```

#### Geometry/Math → `utils/geometry.ts`
```typescript
// ✅ Good - reusable math functions
export function distance(p1, p2) { ... }
export function centerOfCanvas() { return { x: 2500, y: 2500 }; }
export function constrainToAxis(dx, dy) { ... }
export function rotatePoint(point, angle, origin) { ... }
```

#### Shape Matching/Search → `utils/shapeMatching.ts`
```typescript
// ✅ Good - AI tool helper functions
export function findShapeByDescription(desc, shapes) { ... }
export function filterShapesByColor(color, shapes) { ... }
export function findShapesNearPosition(x, y, shapes, threshold) { ... }
```

#### ID Generation → `utils/id.ts`
```typescript
// ✅ Good - simple utilities get their own file
export function generateShapeId() { ... }
export function generateUserId() { ... }
```

#### Validation → `utils/validation.ts`
```typescript
// ✅ Good - input validation
export function isValidColor(color) { ... }
export function isValidCoordinate(x, y) { ... }
export function sanitizeShapeProps(props) { ... }
```

#### WebSocket → `utils/websocket.ts` or `services/websocket.ts`
```typescript
// ✅ Good - WebSocket logic centralized
export function broadcastOperation(operation) { ... }
export function subscribeToCanvas(canvasId, callback) { ... }
```

### Constants Management
```typescript
// constants/canvas.ts
export const CANVAS_WIDTH = 5000;
export const CANVAS_HEIGHT = 5000;
export const CANVAS_CENTER = { x: 2500, y: 2500 };
export const DEFAULT_SHAPE_COLOR = '#3B82F6';
export const DEFAULT_STROKE_WIDTH = 2;

// constants/tools.ts
export const TOOL_TYPES = {
  HAND: 'hand',
  RECTANGLE: 'rectangle',
  CIRCLE: 'circle',
} as const;
```

## Unifying Logic Patterns

### Before Creating New Code, Check:
1. Does a similar function already exist in utils/?
2. Can this be a hook instead of duplicating logic in components?
3. Is this shape logic that should be in utils/canvas.ts?
4. Is this a constant that should be in constants/?
5. Should this be extracted from a component into a service?

### Common Patterns to Unify

#### ❌ BAD - Duplicated shape creation
```typescript
// In ComponentA.tsx
const newShape = {
  id: `shape_${Date.now()}_${Math.random()}`,
  type: 'rectangle',
  x: x || 500,
  y: y || 500,
  fill: color || '#3B82F6'
};

// In ComponentB.tsx
const shape = {
  id: generateId(),
  type: 'circle',
  x: x ?? 500,
  y: y ?? 500,
  fill: color ?? '#3B82F6'
};
```

#### ✅ GOOD - Unified shape factory
```typescript
// utils/shapeFactory.ts
import { generateId } from './id';
import { CANVAS_CENTER, DEFAULT_SHAPE_COLOR } from '../constants/canvas';

export function createShape(type, props = {}) {
  return {
    id: generateId(),
    type,
    x: props.x ?? CANVAS_CENTER.x,
    y: props.y ?? CANVAS_CENTER.y,
    fill: props.fill ?? DEFAULT_SHAPE_COLOR,
    ...props
  };
}

// Usage everywhere
import { createShape } from '@/utils/shapeFactory';
const rect = createShape('rectangle', { width: 100, height: 50 });
const circle = createShape('circle', { radius: 25, fill: '#FF0000' });
```

#### ❌ BAD - Duplicated coordinate calculations
```typescript
// In multiple files
const centerX = 5000 / 2;
const centerY = 5000 / 2;

// Different file
const center = { x: 2500, y: 2500 };

// Another file
if (x > 0 && x < 5000 && y > 0 && y < 5000) { ... }
```

#### ✅ GOOD - Unified geometry utilities
```typescript
// utils/geometry.ts
import { CANVAS_WIDTH, CANVAS_HEIGHT, CANVAS_CENTER } from '../constants/canvas';

export function getCanvasCenter() {
  return CANVAS_CENTER;
}

export function isWithinCanvas(x, y) {
  return x >= 0 && x <= CANVAS_WIDTH && y >= 0 && y <= CANVAS_HEIGHT;
}

export function clampToCanvas(x, y) {
  return {
    x: Math.max(0, Math.min(CANVAS_WIDTH, x)),
    y: Math.max(0, Math.min(CANVAS_HEIGHT, y))
  };
}
```

#### ❌ BAD - Duplicated WebSocket logic
```typescript
// In ComponentA
ws.send(JSON.stringify({ type: 'UPDATE_SHAPE', ... }));

// In ComponentB
websocket.send(JSON.stringify({ type: 'UPDATE_SHAPE', ... }));

// In ComponentC
socket.send(JSON.stringify({ type: 'UPDATE_SHAPE', ... }));
```

#### ✅ GOOD - Unified WebSocket service
```typescript
// services/websocket.ts
class WebSocketService {
  send(message) {
    this.ws.send(JSON.stringify(message));
  }
  
  broadcastShapeUpdate(shapeId, updates) {
    this.send({
      type: 'UPDATE_SHAPE',
      shapeId,
      updates,
      timestamp: Date.now()
    });
  }
  
  broadcastShapeCreate(shape) {
    this.send({
      type: 'CREATE_SHAPE',
      shape,
      timestamp: Date.now()
    });
  }
}

export const wsService = new WebSocketService();

// Usage everywhere
import { wsService } from '@/services/websocket';
wsService.broadcastShapeUpdate(id, { x: 100, y: 200 });
```

## React Component Guidelines

### Extract Logic to Hooks
```typescript
// ❌ BAD - Logic duplicated in components
function ComponentA() {
  const [shapes, setShapes] = useState([]);
  const addShape = (shape) => {
    setShapes(prev => [...prev, { ...shape, id: generateId() }]);
  };
}

function ComponentB() {
  const [shapes, setShapes] = useState([]);
  const addShape = (shape) => {
    setShapes(prev => [...prev, { ...shape, id: generateId() }]);
  };
}

// ✅ GOOD - Shared hook
// hooks/useShapes.ts
export function useShapes() {
  const [shapes, setShapes] = useState([]);
  
  const addShape = useCallback((shape) => {
    setShapes(prev => [...prev, createShape(shape.type, shape)]);
  }, []);
  
  const updateShape = useCallback((id, updates) => {
    setShapes(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
  }, []);
  
  return { shapes, addShape, updateShape };
}

// Usage
import { useShapes } from '@/hooks/useShapes';
function MyComponent() {
  const { shapes, addShape } = useShapes();
}
```

## TypeScript Type Unification

### Centralize Types
```typescript
// types/canvas.ts
export interface Shape {
  id: string;
  type: 'rectangle' | 'circle' | 'text' | 'line';
  x: number;
  y: number;
  fill?: string;
  stroke?: string;
  strokeWidth?: number;
  rotation?: number;
}

export interface Rectangle extends Shape {
  type: 'rectangle';
  width: number;
  height: number;
}

export interface Circle extends Shape {
  type: 'circle';
  radius: number;
}

// Use throughout codebase
import type { Shape, Rectangle } from '@/types/canvas';
```

## Code Review Checklist

Before writing new code, ask:
- Does this function already exist in utils/?
- Can I use an existing hook instead?
- Should this be extracted to a service?
- Am I using constants or magic numbers?
- Is this shape logic that belongs in shapeFactory?
- Can this be a pure function?
- Is this calculation duplicated elsewhere?
- Should this be in utils/geometry.ts?

When refactoring:
- Have I checked all usages of similar code?
- Did I update all duplicates to use the new shared function?
- Are my function names descriptive and consistent?
- Did I add JSDoc comments for complex functions?
- Can this function be more generic/reusable?

## Naming Conventions

### Functions
- Prefix with verb: `createShape`, `updatePosition`, `findShape`, `calculateDistance`
- Be specific: `getShapeById` not `get`, `filterShapesByColor` not `filter`
- Boolean functions: `isWithinCanvas`, `hasPermission`, `canEdit`

### Files
- Lowercase with hyphens: `shape-factory.ts`, `websocket-service.ts`
- Group related utilities: `geometry.ts`, `validation.ts`, `colors.ts`
- Match content: if file exports `createShape`, name it `shape-factory.ts` not `utils.ts`

### Constants
- SCREAMING_SNAKE_CASE: `CANVAS_WIDTH`, `DEFAULT_COLOR`
- Group in objects: `TOOL_TYPES.RECTANGLE`, `COLORS.PRIMARY`

## When to Create New Files

Create a new utility file when:
- You have 3+ related functions
- The file would be >200 lines
- Functions serve a distinct purpose (geometry, validation, etc.)
- Multiple components/tools need these functions

Don't create a new file when:
- You have 1-2 simple functions → add to existing relevant file
- It's component-specific logic → keep in component or custom hook
- It's a single constant → add to existing constants file

## Summary

**Golden Rules:**
1. **Look before you code** - Search for existing utilities first
2. **Extract at 2** - If you see similar code twice, extract it
3. **One source of truth** - Constants, types, utilities should have ONE definition
4. **Pure over impure** - Prefer pure functions that return values over side effects
5. **Name it well** - Good names make code self-documenting
6. **Think reusability** - Write functions that could be used in other contexts

**When in doubt:**
- Is this shape logic? → `utils/shapeFactory.ts` or `utils/canvas.ts`
- Is this math/geometry? → `utils/geometry.ts`
- Is this a constant? → `constants/`
- Is this React state logic? → `hooks/`
- Is this API/external service? → `services/`
- Is this validation? → `utils/validation.ts`

Remember: **Clean, DRY code is faster to write, easier to debug, and simpler to extend.**

